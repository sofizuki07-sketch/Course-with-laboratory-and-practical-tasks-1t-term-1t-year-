# Лабораторная работа №2: Структуры (struct) в языке C

## Задача 1: Структура «Студент» с функцией вычисления среднего балла
Создайте структуру `Student`, содержащую поля: имя (массив символов), массив из 5 оценок (целых чисел) и указатель на функцию. Реализуйте функцию `calculateAverage`, которая вычисляет средний арифметический балл студента. В поле-указатель структуры присвойте адрес этой функции. В программе создайте переменную типа `Student`, заполните её данные, затем вызовите функцию через указатель и выведите средний балл.

## Задача 2: Структура для работы с дробями
Реализуйте структуру `Fraction`, представляющую обыкновенную дробь (числитель и знаменатель). Напишите функции для:
- сложения двух дробей,
- вычитания,
- умножения,
- деления,
- сокращения дроби (алгоритм Евклида).
Каждая функция должна принимать одну или две структуры `Fraction` и возвращать новую структуру с результатом. Продемонстрируйте работу всех функций на примерах.

## Задача 3: Структура «Книга» с вложенной структурой «Автор»
Создайте структуру `Author` с полями: имя, фамилия, год рождения. Затем создайте структуру `Book`, содержащую поля: название, год издания, цену и вложенную структуру `Author`. Реализуйте функцию, которая выводит информацию о книге в читаемом формате. В программе создайте массив из 3–5 книг, заполните его и выведите информацию обо всех книгах.

## Задача 4: Структура с битовыми полями для RGB-цвета
Используя битовые поля, создайте структуру `RGBColor`, которая компактно хранит компоненты цвета:
- красный (5 бит),
- зелёный (6 бит),
- синий (5 бит) (стандарт RGB565).
Напишите функции:
- `setColor` – установка цвета через три компонента,
- `getColor` – получение цвета в виде 16-битного значения,
- `printColor` – вывод цвета в формате RGB.
Продемонстрируйте упаковку и распаковку цвета.
Подсазка: RGB-формат = в качестве значений, присвоенных полям структуры, следует взять числа от 0 до 255 

## Задача 5: Односвязный список для хранения строк
Реализуйте структуру `ListNode` для односвязного списка, где каждый узел хранит строку (динамически выделенную) и указатель на следующий узел. Напишите функции:
- `addNode` – добавление строки в конец списка,
- `printList` – вывод всех строк,
- `deleteList` – освобождение памяти.
Программа должна читать строки с клавиатуры до ввода пустой строки и выводить весь список.

---

## Теоретическая справка по теме «Структуры в C»

### Основные понятия:
1. **Структура (struct)** – составной тип данных, позволяющий объединить переменные разных типов под одним именем.
2. **Поля структуры** – элементы, входящие в структуру, каждый со своим типом и именем.
3. **Вложенные структуры** – структуры, содержащие другие структуры как поля.
4. **Указатели на структуры** – используются для эффективной работы с динамическими структурами данных.
5. **Битовые поля** – специальные поля структуры, занимающие определённое количество бит, для компактного хранения данных.

### Полезные материалы для изучения:
- **Глава 6(Структуры)** - темы 1-5, 10 [Metanit.com](https://metanit.com/c/tutorial/)
- **RGB** - [Foxford.Учебник](https://foxford.ru/wiki/informatika/kak-kodiruetsya-cvet?utm_referrer=https%3A%2F%2Fwww.google.com%2F)
- **Односвязный список** - [Foxford.Учебник](https://foxford.ru/wiki/informatika/dinamicheskiy-odnosvyaznyy-spisok-na-s?srsltid=AfmBOop6NXvO1S-9b6EJ1N0wkHazysuGxALaEeRfh-4Y55T7quhRAEBQ)

### Ключевые моменты для запоминания:
- Структура объявляется с ключевым словом `struct`
- Доступ к полям осуществляется через точку `.` для переменных и через стрелку `->` для указателей
- Размер структуры может быть больше суммы размеров полей из-за выравнивания (padding)
- Битовые поля экономят память, но могут снижать производительность и зависят от реализации компилятора
- Структуры можно передавать в функции по значению или по указателю

### Практические советы:
- Для больших структур передавайте их в функции по указателю, чтобы избежать копирования
- Используйте `typedef` для создания короткого имени структуры
- Инициализируйте структуры при создании, чтобы избежать неопределённых значений
- При работе с динамическими структурами данных не забывайте освобождать память
